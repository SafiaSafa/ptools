#!/usr/bin/env python

##
## script to cluster solutions generated by Attract
## 
## usage : cluster2.py arg1 arg2 [options]
##
## arg1 : output file generated by attract_ff2.py script
## arg2 : ligand file use during the docking procedure
## options :
##
## if you want to modify the cutoff value when comparing Rmsd or energy, 
## specify the -r or -e option (default value for both = 1.0)
## if you want to increase the number of best solution (according to the energy) that are clustered
## specify the -s (or --nstruct) option. (default=2000)
## if you want to increase the number of cluster that are compared to the current structure 
## during the clustering process, specify the -c (or --cluster_memory) option (default=50)
##
## for example, to increase the scut and increase the Rmsd cutoff value,
## the following command should be used:
## > cluster2.py arg1 agr2 -scut 5000 -r 1.5
##

import sys
from optparse import OptionParser
import re
import shelve

import Extract
from ptools import *
from calculateonce import NoRecalc


limit_rmsd = 1.0 
limit_ener = 1.0e30



class Clusterize(NoRecalc):
    def generate(self, db, dep, args):
        retval = cluster(args[0],args[1],args[2],args[3])
        d = shelve.open(db)
        d['data']=retval
        d['args']=args[2:4]
        d.close()
        return retval

    def load(self, db):
        d = shelve.open(db)
        return d['data']

    def checkArgs(self, dbf, args):
        d = shelve.open(dbf)
        return d['args']== args[2:4]



class Struct:
    pass
    #structure = None
    #count = 0


########################
# from Extract.py

class StructureI:
    def __cmp__(self, other):
            if self.trans < other.trans:
                return -1
            if self.trans > other.trans:
                return 1
            return cmp(self.rot, other.rot)
    pass





######################



def cluster(lig,structures, nstruct, cluster_memory):
    cluster_memory_= cluster_memory+1
    thecluster = []

    structures.sort(key=lambda i: i.ener)

    for s in structures[:nstruct]:
        if s.ener>0:
            break
        new=True
        sc = Extract.rigidXMat44(lig,s.matrix)

        for c in reversed(thecluster[-cluster_memory:]):
            if ( ( c.ext.ener-s.ener < limit_ener ) and ( Rmsd(sc,c.structure) < limit_rmsd ) ):
            #if Rmsd(sc,c.structure)< limit_rmsd:
                c.count += 1
                new=False
                #print "stuct added to a cluster"
                break
        if new==True:
            c = Struct()
            c.structure = sc
            c.ext = s
            c.count = 1
            thecluster.append(c)
            if len(thecluster) > cluster_memory:
                del thecluster[-cluster_memory_].structure
            #print "new cluster"
    
    for i in thecluster:
        if hasattr(i,"structure"): del i.structure
    thecluster.sort(key=lambda i: i.ext.ener)
    return thecluster



if (__name__=="__main__"):
    parser = OptionParser()
    parser.usage = 'cluster.py <out_file> <lig_file> [options]'
    parser.add_option("-e", "--energy_cutoff", action="store", type="float", dest="energy_cutoff", help="Energy cutoff value (default=1000.0)")
    parser.add_option("-r", "--rmsd_cutoff", action="store", type="float", dest="rmsd_cutoff", help="Rmsd cutoff value (default=1.0)")
    parser.add_option("-n", "--nstruct", action="store", type="int", dest="nstruct", help="number of structures to cluster, an increase of this value will increase significantly the time processing (default = 2000)")
    parser.add_option("-m", "--memory", action="store", type="int", dest="cluster_memory",default=50, help="only the latest m clusters are compared during the clustering process, an increase of this value will increase significantly the time processing  (default=50)")
    (options, args) = parser.parse_args()
    
    
    

    nstruct=2000
    #cluster_memory=50
    
    if (options.energy_cutoff):
        limit_ener=options.energy_cutoff
    if (options.rmsd_cutoff):
        limit_rmsd=options.rmsd_cutoff
    if (options.nstruct):
        nstruct=options.nstruct
    if (options.cluster_memory):
        cluster_memory=options.cluster_memory


    outputfile = sys.argv[1]
    ligandfile = sys.argv[2]
    lig = Rigidbody(ligandfile)

    e = Extract.Extractor(outputfile)   #extracts output structures or reuse the generated database
    validkeys=[]
    regexp = re.compile("[0-9]+:[0-9]+")  #filter keys of the form "23:356"
    for k in e.d.keys():
        if regexp.match(k):
            validkeys.append(k)


    #_,structures = readStructures(outputfile)
    structures=[]
    for k in validkeys:
        structures.append(e.d[k])


    dependencies=[outputfile]
    args = [lig,structures, nstruct, cluster_memory]



    thecluster=Clusterize("%s.cluster.db"%outputfile,dependencies,args,info_output=sys.stderr.write, error_output=sys.stderr.write).db


    print "%-4s %6s %6s %13s %13s %6s %8s"  %(" ","Trans", "Rot", "Ener", "RmsdCA_ref","Rank", "Weight")
    for i in range(len(thecluster)):
             print "%-4s %6s %6s %13.7f %s %6i %8s" %("==", str(thecluster[i].ext.trans), str(thecluster[i].ext.rot), float(thecluster[i].ext.ener), thecluster[i].ext.rmsd, i+1, str(thecluster[i].count))



