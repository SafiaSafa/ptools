\documentclass[12pt,a4paper]{article}
\usepackage{ae}
\usepackage{aecompl}
%\usepackage[cm]{aeguill}
\textwidth 16.5cm \textheight 26cm \oddsidemargin -0.5cm \topmargin -2cm
\usepackage{graphicx} % figures
\usepackage{lineno}

\begin{document}

\setlength{\parindent}{0pt}


\title{\bf PTools tutorial}

\author{Adrien Saladin $^{1,2}$
\and S\'ebastien Fiorucci$^{1,4}$
\and Pierre Poulain$^3$
\and Chantal Pr\'evost$^2$
 and Martin Zacharias$^1$
}

\maketitle
\thispagestyle{empty}

\noindent
{\scriptsize
$^1$ Computational Biology, School of Engineering and Science, Jacobs University Bremen, 28759 Bremen, Germany\\
$^2$ LBT, CNRS UPR 9080 and Univ. Paris Diderot - Paris 7, IBPC, 13 rue Pierre et Marie Curie, 75005 Paris, France   \\
$^3$ DSIMB team, Inserm UMR-S 665 and Univ. Paris Diderot - Paris 7, INTS,
6 rue Alexandre Cabanel, 75015 Paris, France   \\
$^4$ LCMBA, UMR-CNRS 6001, Facult\'e des Sciences, Universit\'e de Nice-Sophia Antipolis, 06108 Nice Cedex 2, France. \\
}

\vspace*{1cm}
\begin{figure}[htbp]
\center
\includegraphics*[width=0.80\linewidth]{img/docking.png}
\end{figure}

\vspace*{1cm}
If you use PTools, please cite: \\
A.~Saladin, S.~Fiorucci, P.~Poulain, C.~Pr\'evost, and M.~Zacharias,\\
PTools: an opensource molecular docking library,\\
BMC Structural Biology 9: 27 (2009).

\vspace*{1cm}

\noindent
This tutorial presents the PTools library features and its docking application ATTRACT.

\newpage

\tableofcontents{}

\newpage

\section{Set up, compilation and installation}

\subsection{Basic requirements}

The basic requirements are:
\begin{itemize}

\item g++ (4.x)
\item gfortran (4.x) or g77
\item doxygen (optional)
\item the Boost C++ library
\item SCons
\end{itemize}

The following tools are also necessary in order to use the library as a Python module:
\begin{itemize}
\item Python 2.4 or 2.5 and its development library (python2.4-dev or python2.5-dev)
\item gccxml (may require cmake and cvs if you need to compile it from sources).
\item pygccxml
\item py++
\item the Boost.Python library (which is not part of the main Boost C++ library on some linux distributions)
\end{itemize}

Software locations and install instructions will be given below.

In the following, we assume the PTools library will be installed in the 
\verb@$HOME/soft@ directory where \verb@$HOME@ represents the home directory
(usually {\tt /home/adrien} for the user {\tt adrien}).


\subsection{Installing prerequisites}

\subsubsection{On Debian or Debian-like systems (Ubuntu)}

\begin{verbatim}
apt-get install scons libboost-dev libbost-python-dev gccxml
\end{verbatim}
%
See \ref{pyplusplus} for installing necessary tools for building python bindings.


\textbf{Note}: some Debian Ubuntu systems have an old version of gccxml that doesn't work well for binding this
library. If bindings generation or unit tests fail, you should consider installing gccxml manually (see \ref{gccxml})

gccxml versions $\le 0.6$ crash during bindings generation. gccxml v. $0.9$ from Debian Lenny contains a bug that prevents all Python unit tests to work (test 16 fails).


\subsubsection{On Fedora systems}

\paragraph{SCons (make substitute):}
The scons package provided by Fedora is not up-to-date enough to link Fortran and C++ together and then rise an
error. The last version of scons is obtained at the homepage of the project ({\tt  http://www.scons.org/}).
From the download section \footnote{\tt http://sourceforge.net/project/showfiles.php?group\_id=30337}, 
get the stable file {\tt scons-0.98.5-1.noarch.rpm} and install it:

\begin{verbatim}
 rpm -ivh scons-0.98.5-1.noarch.rpm
\end{verbatim}

\textbf{Note}: SCons 0.98.5 and 1.0.0 were successfully tested


You can then install some packages:

\begin{verbatim}
  yum install boost boost-devel python-devel
\end{verbatim}


After that, you still need to manually install gccxml, pyplusplus and pygccxml (see below).


\subsubsection{gccxml\label{gccxml}}

The homepage of {\tt gccxml} project is {\tt http://www.gccxml.org} and its official 
CVS repository is {\tt http://www.gccxml.org/HTML/Download.html}.

\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML login
\end{verbatim}
(just press enter when prompted for a password)\\
Follow this command by checking out the source code:
\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML co gccxml
mkdir gccxml-build
cd gccxml-build
cmake ../gccxml -DCMAKE_INSTALL_PREFIX:PATH=/installation/path
make
make install
\end{verbatim}
The \verb@-DC_MAKE_INSTALL_PREFIX@ option can be left off if you want to use \verb@/usr/local@ as the installation prefix.


\subsubsection{Pyplusplus and Pygccxml: \label{pyplusplus}}
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is 
{\tt http://www.language-binding.net/pyplusplus/pyplusplus.html}. From the
download section \footnote{\tt https://sourceforge.net/project/showfiles.php?group\_id=118209}, 
get the files {\tt pygccxml-0.9.5.zip} and {\tt Py++-0.9.5.zip}.

\begin{verbatim}
unzip pygccxml-0.9.5.zip
cd pygccxml-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip Py++-0.9.5.zip 
cd Py++-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=$PATH:$HOME/soft/bin/
export PYTHONPATH=$HOME/soft/lib/python2.4/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}






\subsection{Compilation}

Dowload the PTools library and untar it:

\begin{verbatim}
tar zxvf ptools-XX.tar.gz
\end{verbatim}
The directory {\tt ptools-XX} should be created.


\subsubsection{Static pure C++ library}

Move into the new directory and type:

\begin{verbatim}
 scons cpp
\end{verbatim}

This should create the file {\tt libptools.a}.

If SCons cannot locate a fortran compiler or a library, you can define a search path at the beginning of
the {\tt SConstruct} file.

\subsubsection{The library as a Python module}

From the PTools main directory ({\tt \$HOME/soft/ptools-XX}), 
first create the Python/C++ interface:
\begin{verbatim}
python interface.py
\end{verbatim}

Then compile the library:
\begin{verbatim}
scons
\end{verbatim}

Note that {\tt scons -j2} compiles with two processors in parallel.

If SCons cannot locate a fortran compiler or a library, you can define a search path at the beginning of
the {\tt SConstruct} file.


\subsection{Final test and further documentation}

\subsubsection{C++ library only}

The PTools library has a new C++ unit test system. To try it move into the {\tt Tests/} directory and
type: 
\begin{verbatim}
 make testcpp
\end{verbatim}

You should get something like this:

\begin{verbatim}
running C++ tests
python cxxtestgen.py --error-printer ptoolstest.h > runner.cpp
g++ runner.cpp -I.. -I. -L.. -lptools -o ptoolstest.bin
./ptoolstest.bin
Running 15 tests...............OK!
\end{verbatim}


\subsubsection{Python module}
In the {\tt Tests} directory, one can test that the compilation worked:
\begin{verbatim}
python unittest1.py
\end{verbatim}

The expected output should be similar to:
\begin{verbatim}
...............
----------------------------------------------------------------------
Ran 16 tests in 0.316s

OK
\end{verbatim}


\section{PTools library usages and capabilities}

\subsection{Directly from C++}

Source code may be parsed by Doxygen, an automatic documentation generator.
This documentation may help for the C++ (and indirectly for the Python)
part of the library. 

If Doxygen is installed, simply type {\tt doxygen} in
the directory which contains the {\tt Doxyfile} ({\tt
\$HOME/soft/ptools-XX}). Then look into the {\tt html}
directory and open with your favorite web browser the {\tt index.html} file
generated by doxygen. 

The most important objects and functions to manipulate PDB files are explained in
the following section.

\subsection{From Python through the C++ binding}

If PTools has been installed in the \verb@$HOME/soft/ptools-XX@ directory, 
update your {\tt PYTHONPATH} environment variable accordingly:

\begin{verbatim}
export PYTHONPATH=$PYTHONPATH:$HOME/soft/ptools-XX/
\end{verbatim}
or add this line at the end of your \verb@$HOME/.bashrc@ file.


From the Python interpreter or from a Python script, 
first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}


\subsubsection{Rigidbody objects}

\paragraph{Load PDB file (for instance {\tt 1BTA.pdb}) into a rigidbody
object.}
\begin{verbatim}
pdb = Rigidbody("1BTA.pdb")
\end{verbatim}


\paragraph{Number of atoms.}
\begin{verbatim}
pdb.Size()
\end{verbatim}


\paragraph{Maximum distance (in \AA) from geometric center.}
\begin{verbatim}
pdb.Radius()
\end{verbatim}


\paragraph{Radius of gyration (in \AA).}
\begin{verbatim}
pdb.RadiusGyration()
\end{verbatim}


\paragraph{Structure translation.}
First create a translation vector as a Coord3D object (for instance +5~\AA\ along the X axis, -3~\AA\ along Y and +1~\AA\ along the Z axis):
\begin{verbatim}
trans = Coord3D(5, -3, 1)
\end{verbatim}
Then, apply the translation vector {\tt trans}:
\begin{verbatim}
pdb.Translate(trans)
\end{verbatim}


\paragraph{Center structure to origin.}
\begin{verbatim}
pdb.CenterToOrigin()
\end{verbatim}


\paragraph{Save structure as PDB file.}
\begin{verbatim}
WritePDB(pdb, "1BTA_centered.pdb")
\end{verbatim}


\paragraph{Superpose two structures.} This is a complete example where we
superpose a structure and its copy after a translation.\\

\noindent
First, load a PDB file as a Rigidbody object
\begin{verbatim}
pdb = Rigidbody("1BTA.pdb")
\end{verbatim}
Make a copy
\begin{verbatim}
pdb2 = Rigidbody(pdb)
\end{verbatim}
Create a translation vector
\begin{verbatim}
trans = Coord3D(5, 0, 1)
\end{verbatim}
Apply the translation on the copy
\begin{verbatim}
pdb2.Translate(trans)
\end{verbatim}
Superpose both structures
\begin{verbatim}
sup = superpose(pdb, pdb2)
\end{verbatim}
Extract RMSD and matrix
\begin{verbatim}
rmsd = sup.rmsd
matrix = sup.matrix
\end{verbatim}
Print RMSD
\begin{verbatim}
print rmsd
\end{verbatim}
The output is {\tt 1.22224104574e-07} (in \AA). Then print the $4 \times 4$ matrix:
\begin{verbatim}
matrix.Print()
\end{verbatim}
with output:
\begin{verbatim}
1  8.07909e-09  -5.80388e-09  1.42535e-09  
-8.07909e-09  1  2.0426e-09  2.54026e-08  
5.80388e-09  -2.0426e-09  1  -1.86091e-08  
0  0  0  1  
\end{verbatim}


\subsubsection{Selection objects}

\paragraph{Select CA atoms.}
\begin{verbatim}
sel_ca = pdb.CA()
\end{verbatim}


\paragraph{Select backbone atoms.}
\begin{verbatim}
sel_bkbn = pdb.Backbone()
\end{verbatim}


\paragraph{Select by chain.}
\begin{verbatim}
sel_chainA = pdb.SelectChainId("A")
sel_chainB = pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Select a range of residues.}
\begin{verbatim}
sel_res = pdb.SelectResRange(10, 20)
\end{verbatim}


\paragraph{Get the number of atomes (the size) of a selection.}
\begin{verbatim}
sel_res.Size()
\end{verbatim}



\paragraph{Reunion between two selections.}
\begin{verbatim}
sel_chainAB = sel_chainA | sel_chainB
\end{verbatim}
or directly
\begin{verbatim}
sel_chainAB = pdb.SelectChainId("A") | pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Convert selection to rigidbody object.}
\begin{verbatim}
ca_trace = sel_ca.CreateRigid()
\end{verbatim}

\subsubsection{atom objects}

\paragraph{Copy atom from rigidbody object.} In this example, the third atom (indexed as 2 since the first atom in numberered 0) is copied.
\begin{verbatim}
at = pdb.CopyAtom(2)
\end{verbatim}

\paragraph{Set new coordinates}
\begin{verbatim}
new_XYZ = Coord3D(2.1,3.9,5.5)
at.SetCoords(new_XYZ)
\end{verbatim}

\paragraph{Translate atom}
\begin{verbatim}
vector = Coord3D(1.0,1.0,1.0)
at.Translate(vector)
\end{verbatim}


\paragraph{Print atom in pdb-like format}
\begin{verbatim}
at.ToPdbString()
\end{verbatim}

\paragraph{Get atom properties}
\begin{verbatim}
at.GetType()
at.GetResidType()
at.GetAtomCharge()
at.GetChainId()
at.GetResidId()
at.GetAtomId()
at.GetExtra()
\end{verbatim}

\paragraph{Set atom properties}
\begin{verbatim}
at.SetType()
at.SetResidType()
at.SetAtomCharge()
at.SetChainId()
at.SetResidId()
at.SetAtomId()
at.SetExtra()
\end{verbatim}

\section{Docking with PTools: ATTRACT}

This part shows the PTools docking application called ATTRACT\cite{Zacharias2005}. It usage and 
capabilities are illustrated by the docking of a protein--protein complex (1CGI) 
and a protein--DNA complex\cite{Poulain2008} (1K79). The first example (1CGI) is explained 
step by step and scripts usages are exhaustively detailled. The second example 
(1K79) is much more straightforward.

\subsection{Protein--protein complex: 1CGI}

The 1CGI complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1CGI} 
has two partners,
\begin{itemize}
\item the bovine chymotrypsinogen A: chain E, 245 residues, 1799 atoms
\item a variant of the human pancreatic secretory trypsin inhibitor: chain I, 56 residues, 440 atoms
\end{itemize}

\subsubsection{Extraction of the docking partners}

Before docking, one has to separate both partners. This is possible with vizualisation
software such as Pymol \footnote{\tt http://pymol.sourceforge.net/} or VMD \footnote{\tt http://www.ks.uiuc.edu/Research/vmd/}, 
and also directly with PTools.

Within the Python interpreter, first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}

Read the PDB file of the complex:
\begin{verbatim}
pdb=Rigidbody("1CGI.pdb")
\end{verbatim}

The chain selection allows the separation between chain E and I.
\begin{verbatim}
selectE=pdb.SelectChainId("E")
selectI=pdb.SelectChainId("I")
\end{verbatim}

Create both chains as independant Rigidbody objects and save them in PDB files. 
The largest protein is defined as the receptor (chain E) and the smallest 
as the ligand (chain I).

\begin{verbatim}
protE=selectE.CreateRigid()
protI=selectI.CreateRigid()
WritePDB(protE,"receptor.pdb")
WritePDB(protI,"ligand.pdb")
\end{verbatim}
Or more quickly:
\begin{verbatim}
WritePDB(selectE.CreateRigid(),"receptor.pdb")
WritePDB(selectI.CreateRigid(),"ligand.pdb")
\end{verbatim}

\subsubsection{Coarse grain reduction}

This step translates all-atom molecules into coarse grain (reduced) molecules for further docking. 

For the receptor: 
\begin{verbatim}
./reduce.py --prot receptor.pdb > receptor.red
\end{verbatim}
In the present case, {\tt receptor.red} contains 522 beads.\\

For the ligand:
\begin{verbatim}
./reduce.py --prot ligand.pdb > ligand.red
\end{verbatim}
In this example, {\tt ligand.red} contains 126 beads. \\

The {\tt reduce.py} script requires the following parameters:

\begin{itemize}
\item \verb@--prot@ or \verb@--dna@ option, specifies the type of molecule to reduce (respectively protein or DNA)
\item an input all-atom PDB file, for instance {\tt receptor.pdb}
\item an output coarse grain file, for instance {\tt receptor.red}
\end{itemize}

This script also needs some definition files:

\begin{itemize}
\item beads topology files ({\tt at2cg.prot.dat} for protein reduction and {\tt at2cg.dna.dat} for DNA reduction )
\item forcefield parameters file ({\tt ff\_param.dat})
\item filetypes conversion file ({\tt type\_conversion.dat})
\end{itemize}

The reduced files generated are PDB-like structure files that can be read by many visualization programs (Rasmol, Pymol, VMD). Always visualize both all-atom and coarse grain structures to check the reduction worked properly (see Fig.~\ref{1CGI_at_cg} for 1CGI).

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.25\textwidth]{img/1CGI_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation of 
both proteins in the 1CGI complex. Receptor (A) and ligand (B).}
\label{1CGI_at_cg}
\end{figure}

\subsubsection{Initial ligand positions}

A systematic docking simulation uses starting points placed all around the
receptor.  The Python script {\tt translate.py} employs a slightly modified
Shrake and Rupley \cite{Shrake1973} method to define starting positions
from the receptor surface.  The surface generation fonctions are implemented in
the PTools library. The script first reads the coarse grain (reduced)
receptor and ligand files, then generates a grid of points at a certain
distance from the receptor and outputs the grid with a given density.

Note: a density option ({\tt -d}) controls the minimum distance between starting
points (in \AA). The default value is 10.0~\AA. 

In the present case:
\begin{verbatim}
./translate.py receptor.red ligand.red > translation.dat
\end{verbatim}

Vizualization of the starting points may be obtained with any vizualisation 
software by renaming {\tt translation.dat} in {\tt translation.pdb} and then
by removing the first line of {\tt translation.pdb} (that indicates the total 
number of starting points). In this example, Fig.~\ref{1CGI_translation} shows
the receptor surounded by the 204 starting points.

\begin{figure}[htbp]
\center
\includegraphics*[width=0.4\textwidth]{img/1CGI_translation.png}
\caption{Coarse grain receptor in green spheres and starting points as orange spheres.}
\label{1CGI_translation}
\end{figure}

For each position in translation (each {\tt ATOM} line of the file {\tt translation.dat}), 
there are 258 associated rotations defined in the file {\tt rotation.dat}. 

\subsubsection{ATTRACT parameters}

ATTRACT parameters are found in the file {\tt attract.inp}, which typical content is :

\linenumbers*
\begin{verbatim}
    6    0    0
 -34.32940  38.75490  -3.66956   0.00050
  100  2  1  1  1  0  0  0  1  9900.00
  100  2  1  1  1  0  0  0  1  1500.00
  100  2  1  1  1  0  0  0  1  1000.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
\end{verbatim}
\nolinenumbers

Line~1 indicates the number of minimisations performed by ATTRACT
for each starting position (six in the present case). The last six lines (3--8) 
are the characteristics of
each minimisation. The first column is the number of steps before the
minimisation stops.  The last column is the square of the cutoff distance
for the calculation of the interaction energy between both partners. 
In the present case, the simulation starts with a very large cutoff value of 9900~\AA$^2$ 
($\sim$ 99~\AA), which is gradually dicreased
to end with 500~\AA$^2$ ($\sim$ 22~\AA).

\paragraph{Note:} Columns with zeros or ones should not be modified, as
well as line~2. They are used for internal development purposes.

\subsubsection{Simple optimization}

A standard simulation with ATTRACT requires:
\begin{itemize}
\item the ATTRACT Python script ({\tt  Attract.py})
\item a coarse grain receptor (fixed partner) file ({\tt receptor.red})
\item a coarse grain (mobile partner) file ({\tt ligand.red})
\item the coarse grain parameters ({\tt aminon.par})
\item translation starting points ({\tt translation.dat})
\item rotations performed for each translation starting point ({\tt rotation.dat})
\item docking parameters ({\tt attract.inp})
\end{itemize}

ATTRACT can be used with different options:
\begin{itemize}
\item {\tt -s}, performs one single serie of minimisations with the ligand in its initial position.
\item \verb@--ref@, (optional) provides a ligand PDB file as a reference (reduced). After each docking, the RMSD is calculated between this reference structure and the simulated ligand.
\item \verb!--t transnb!, loads only the translation number {\tt transnb} (and all its associated rotations). This option is very usefull for dispatching a simulation over a cluster of computers.
\end{itemize}


A single ATTRACT simulation (optimization) may thus be obtained by:
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red -s > single.att
\end{verbatim}

The first PDB file provided must be the receptor file (and the second the ligand).
The content of the output file {\tt single.att} is the following:

\newpage
\linenumbers*
\begin{verbatim}

**********************************************************************
**                ATTRACT  (Python edition)                         **
**                version: 0.3                                      **
**********************************************************************
Attract.py: $Id: Attract.py 616 2008-11-25 12:42:39Z asaladin $
using PTools: 614

2008-12-11 00:08:18.212859 ( Thursday December 11 2008, 00:08 )
6 series of minimizations
rstk =  0.0005
Receptor (fixed) receptor.red  has 522 particules
Ligand (mobile) ligand.red  has 126 particules
using reference file: ligand.red
Single mode
@@@@@@@ Translation nb 1 @@@@@@@
----- Rotation nb 1 -----
{{ minimization nb 1 of 6 ; cutoff= 99.50 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  72 iterations
{{ minimization nb 2 of 6 ; cutoff= 38.73 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  2 iterations
{{ minimization nb 3 of 6 ; cutoff= 31.62 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  3 iterations
{{ minimization nb 4 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  10 iterations
{{ minimization nb 5 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  1 iterations
{{ minimization nb 6 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  1 iterations
      Trans    Rot          Ener    RmsdCA_ref
==        1      1   -58.3541422 1.19455904733
### MAT BEGIN
MAT        0.9973001      0.0414787     -0.0605965      0.4545131 
MAT       -0.0430245      0.9987753     -0.0244310      1.9814388 
MAT        0.0595089      0.0269722      0.9978633     -2.8603610 
MAT        0.0000000      0.0000000      0.0000000      1.0000000 
### MAT END

Finished at:  Thursday December 11 2008, 00:08

\end{verbatim}
\nolinenumbers

\begin{itemize}
\item{\bf line 9:} starting date and time of the simulation
\item{\bf lines 18--20:} minimization 1. Minimization index, cutoff 
in \AA\ and maximum number of iterations (line~18). 
Number of variables (line~19). End of minimization (line~20), either 
convergence is achieved (the number of performed iterations is specified), 
either maximum number of steps is reached.
\item{\bf lines 21--23:} minimization 2.
\item{\bf lines 24--26:} minimization 3.
\item{\bf lines 27--29:} minimization 4.
\item{\bf lines 30--32:} minimization 5.
\item{\bf lines 33--35:} minimization 6.
\item{\bf lines 36--37:} final result after the 6 minimizations. With a single series of minimization, the default translation ({\tt Trans}) is 1 and the default rotation ({\tt Rot}) is 1. 
Energy ({\tt Ener}) is given in RT unit and the C$_{\alpha}$-RMSD 
({\tt RmsdCA\_ref}) in \AA\ if the \verb@--ref@ option is specified.
\item{\bf lines 38--43:} rotation/translation matrix of the ligand compared to its initial position.
\item{\bf line 45:} end date and time of the simulation.
\end{itemize}

Here, the final energy is -58.4~RT unit and the RMSD is 1.2~\AA, which is pretty close from the initial position. (In a \emph{perfect} simulation, RMSD would be, of course, 0.0~\AA).

\subsubsection{Systematic docking simulation}

For a full systematic docking in the translational and rotational space (using both {\tt translation.dat} and {\tt rotation.dat} files), the command line is:
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red > docking.att &
\end{verbatim}

The output file {\tt docking.att} contains all informations on the docking simulation. 
It contains the ouput of all series of minimizations (with the specification of translation and rotation number).

For the 1CGI complex, the systematic docking took 19 hours on a single processor of a 64~bit Intel Xeon 1.86 GHz 2 Go RAM computer.
The size of the output file {\tt docking.att} is roughly 77~Mo.

\subsubsection{Docking output analysis}

The 10 best geometries found during the docking simulation can be listed with

\begin{verbatim}
cat docking.att | egrep -e "^==" | sort -n -k4 | head
\end{verbatim}

For the previsous docking simulation of 1CGI, this gives:

\begin{verbatim}
==      133     92   -58.3541443 1.19429783478
==       73    229   -58.3541441 1.19413397471
==      133     21   -58.3541437 1.19566121232
==       73    235   -58.3541436 1.19394986862
==      136     21   -58.3541424 1.19584401069
==      130    141   -58.3541411  1.1930478392
==      194    219   -58.3541410  1.1961246513
==       73      7   -58.3541406 1.19314844151
==      136    155   -58.3541400 1.19273140092
==      163     70   -58.3541387 1.19596166869
\end{verbatim}

With each column meaning:
\begin{enumerate}
\item tag characters ({\tt ==}) to quickly find the result of each set of minimizations
\item translation number (starts at 1)
\item rotation number (starts at 1)
\item final energy of the complex in RT unit
\item final RMSD in \AA, if the \verb@--ref@ option is provided.
\end{enumerate}

Any simulated ligand structure can be extracted with the script {\tt Extract.py}:

\begin{verbatim}
./Extract.py docking.att ligand.red 133 92 > ligand_1.red
\end{verbatim}

with the parameters:
\begin{itemize}
\item the ouput file of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item a translation number ({\tt 133})
\item a rotation number ({\tt 92})
\item an output ligand file ({\tt ligand\_1.red})
\end{itemize}

Fig.~\ref{1CGI_dock} shows the best solution of the docking simulation and the
reference complex. With a RMSD of 1.2~\AA\ between both structures, 
the docking simulation found very well the initial complex structure.

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_front.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_top.png}
\caption{Reduced representations of receptor (green), ligand at reference 
position (red) and ligand from the best solution (lowest energy) of the 
docking (blue). Front (A) and top (B) views. Beads have exact van der 
Waals radii.}
\label{1CGI_dock}
\end{figure}


In case an experimental structure of the system is known (as in this example), 
it is possible to calculate the interface RMSD (iRMSD) and the native fraction 
(fnat) as defined by the CAPRI contest \footnote{\tt http://capri.ebi.ac.uk}
using the following scripts:

\begin{verbatim}
irmsd.py receptor.red ligand.red ligand_1.red
fnat.py receptor.red ligand.red ligand_1.red
\end{verbatim}

For iRMSD, output is in \AA\ and fnat is given as a proportion (between 0.0 and 1.0). Parameters are defined as:
\begin{itemize}
\item the receptor file ({\tt receptor.red})
\item the initial ligand file ({\tt ligand.red})
\item the output ligand file ({\tt ligand\_1.red})
\end{itemize}

Our clustering algorithm implemented in {\tt cluster.py} can rapidly filter near identical solutions 
without requiring a preselected number of desired clusters.
The algorithm is based on RMSD comparison and an additional energy criterion can be included 
(see script options, by default RMSD and energy criterions are 1~\AA\ and 1~RT unit respectively).

\begin{verbatim}
cluster.py docking.att ligand.red > docking.clust
\end{verbatim}

with the parameters:
\begin{itemize}
\item an ouput of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item an output cluster file ({\tt docking.clust})
\end{itemize}

The first lines of the output cluster file are:

\linenumbers*
\begin{verbatim}
      Trans    Rot          Ener    RmsdCA_ref   Rank   Weight
==      133     92   -58.3541443     1.1942978      1       55
==      196    132   -40.3704483    48.8195971      2        1
==      164    212   -39.3828793     6.4968451      3        2
==       71    102   -38.7843145    14.7084754      4       14
==       73    126   -38.5826662    11.5175880      5        3
==      129    223   -38.3872389    12.3477797      6        3
==      132    245   -38.3429828    14.0028863      7       10
==      133    131   -38.1570360    16.0382603      8       17
\end{verbatim}
\nolinenumbers

Line 1 is a comment line, next lines are clusters. For each cluster (line)
is specified:
\begin{itemize}
\item a representative structure with the corresponding translation and rotation
numbers (column 2, {\tt Trans}, and 3, {\tt Rot}), interaction energy 
(column 4, {\tt Ener}) and RMSD (column 5, {\tt RmsdCA\_ref}) 
from the reference ligand structure
\item the number of the cluster (column 6, {\tt Rank})
\item the number of structures (docking solutions) in this cluster (column
7, {\tt Weight})
\end{itemize}

The large weight of the best solution shows the very good convergence of the
docking simulation.

\subsection{Protein--DNA complex: 1K79}


The 1K79 complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1K79} 
has two partners,
\begin{itemize}
\item the ETS protein: chain A, 104 residues, 873 atoms (defined in the following as the receptor)
\item a DNA molecule: chain B and C, 30 bases, 607 atoms (defined in the following as the ligand)
\end{itemize}

\subsubsection{Extraction of the docking partners}

Both partners are extracted automatically with PTools from the Python interpreter:
\begin{verbatim}
from ptools import *
pdb=Rigidbody("1K79.pdb")
selA=pdb.SelectChainId("A")
selB=pdb.SelectChainId("B")
selC=pdb.SelectChainId("C")
WritePDB(selA.CreateRigid(), "receptor.pdb")
WritePDB( (selB | selC).CreateRigid(), "ligand.pdb")
exit()
\end{verbatim}

\subsubsection{Coarse grain reduction}

All-atom molecules are then translated into coarse grain (reduced) molecule for further docking. 

For the receptor (protein): 
\begin{verbatim}
./reduce.py --prot receptor.pdb --warnonly > receptor.red
\end{verbatim}

This command generates few warnings due to missing atoms in the Lys436 residue. 
When an atom is missing, the corresponding bead is not created. You will have to check
 if this is an important issue for your system and fix your PDB with your favourite tool.
Please also note that the \verb!reduce! script doesn't report anything you if a complete
 residue is missing (this frequently occurs in loops).


\begin{verbatim}
./reduce.py --prot receptor.pdb > receptor.red
./at2cg.prot.dat: found the definition of residues ARG GLU GLN LYS TRP MET PHE TYR HIS GLY ASN ALA ASP CYS ILE LEU PRO SER THR VAL 
./at2cg.prot.dat: created the partition for residues ARG(3 beads) GLU(3 beads) GLN(3 beads) LYS(3 beads) TRP(3 beads) MET(3 beads) PHE(3 beads) TYR(3 beads) HIS(3 beads) GLY(1 beads) ASN(2 beads) ALA(2 beads) ASP(2 beads) CYS(2 beads) ILE(2 beads) LEU(2 beads) PRO(2 beads) SER(2 beads) THR(2 beads) VAL(2 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file receptor.pdb with 873 atoms 
Number of residues: 104
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom CG in bead CB 16 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom CE in bead CE 17 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 246 beads 
\end{verbatim}

The reduced protein, {\tt receptor.red}, contains 246 beads.\\

For the ligand (DNA), do not forget the \verb@--dna@ option:
\begin{verbatim}
./reduce.py --dna ligand.pdb --warnonly > ligand.red
\end{verbatim}
This also generates few warnings due to incomplete bases:
\begin{verbatim}
./at2cg.dna.dat: found the definition of residues A G C T 
./at2cg.dna.dat: created the partition for residues A(6 beads) G(6 beads) C(5 beads) T(5 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file ligand.pdb with 607 atoms 
Number of residues: 30
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom O1P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O1P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 162 beads
\end{verbatim}

The reduced DNA, {\tt ligand.red}, ends up with 162 beads. \\

As previously said, the reduced files generated are PDB-like structure files 
that can be read by most visualization programs (Rasmol, Pymol, VMD). 
Always visualize both all-atom and coarse grain structures to check the 
reduction worked properly (see Fig.~\ref{1K79_at_cg} for 1K79).

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.35\textwidth]{img/1K79_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.20\textwidth]{img/1K79_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation 
of both partners in 1K79. Receptor, protein (A) and ligand, DNA (B).}
\label{1K79_at_cg}
\end{figure}

\subsubsection{Initial ligand position}

\begin{verbatim}
./translate.py receptor.red ligand.red > translation.dat
\end{verbatim}

In the present case, the {\tt translation.dat} file contains 179 starting points.

\subsubsection{ATTRACT parameters}

The content of the {\tt attract.inp} parameters file is identical to the one
previously used for protein--protein docking.

\subsubsection{Simple optimization}

An ATTRACT optimization is done with:
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red -s > single.att
\end{verbatim}

Here, the final energy is -38.4~RT unit and the RMSD is 1.3~\AA\ which is very close
from the initial position.

Please note, that the RMSD is not computed here on C$_{\alpha}$ atoms since the
ligand is a DNA molecule. The RMSD is calculated with all DNA beads. 

\subsubsection{Systematic docking simulation}

A systematic docking simulation is then:
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red > docking.att &
\end{verbatim}

The output file {\tt docking.att} contains all informations on the docking 
simulation. It contains the ouput of all series of minimizations 
(with the specification of translation and rotation numbers).

For the 1K79 complex, the systematic docking took roughly 11 hours on a single processor of a 64~bit Intel Xeon 1.86 GHz 2 Go RAM computer.
The size of the output file {\tt docking.att} is about 67~Mo.

\subsubsection{Docking output analysis}

The 10 best geometries found during the docking simulation can be listed with :

\begin{verbatim}
cat docking.att | egrep -e "^==" | sort -n -k4 | head
\end{verbatim}

This gives:

\begin{verbatim}
==       30    157   -38.4463924 1.25369709657
==      169     51   -38.4463903 1.25534808001
==      148    234   -38.4463875 1.25581284912
==       87    257   -38.4463867 1.25409925951
==      109    231   -38.4463855 1.25469537295
==      104    236   -38.4463848 1.25571565339
==      144     27   -38.4463848 1.25495212761
==      164    255   -38.4463819 1.25410121719
==      163     27   -38.4463817 1.25446355377
==       87    241   -38.4463806  1.2554586922
\end{verbatim}


We can then extract the best structure obtained (translation number 30 
and rotation number 157, illustrated Fig.~\ref{1K79_dock}):

\begin{verbatim}
./Extract.py docking.att ligand.red 30 157 > ligand_1.red
\end{verbatim}

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1K79_dock1_front.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.30\textwidth]{img/1K79_dock1_top.png}
\caption{Reduced representations of receptor (green), ligand at reference 
position (red) and ligand from the best solution (lowest energy) of the 
docking (blue). Front (A) and top (B) views. Beads have exact van der Waals 
radii. With a RMSD of 1.6~\AA\ between the reference and the simulated ligand 
structures, the docking simulation found very well the initial complex 
structure.}
\label{1K79_dock}
\end{figure}

As for protein--protein example, one can compute the native fraction (fnat).
\begin{verbatim}
fnat.py receptor.red ligand.red ligand_1.red
\end{verbatim}

That gives {\tt 0.824561403509} in this example. However, the interface 
RMSD (iRMSD) calculation is not yet implemented for DNA.


Our clustering algorithm implemented in {\tt cluster.py} can rapidly group
near identical solutions without requiring a preselected number of desired clusters.
The algorithm is based on RMSD comparison and an additional energy criterion can 
be included (see script options, by default RMSD and energy criterions are 
1~\AA\ and 1~RT unit respectively).

\begin{verbatim}
./cluster.py docking.att ligand.red > docking.clust
\end{verbatim}

The first lines of the output cluster file are:

\linenumbers*
\begin{verbatim}
      Trans    Rot          Ener    RmsdCA_ref   Rank   Weight
==       30    157   -38.4463924     1.2536971      1       46
==      152    180   -36.8164268    29.0984166      2       17
==       97    155   -36.3644447    28.7048437      3       21
==       98     56   -36.0763672     6.3710149      4       22
==       32    244   -35.1526795    28.8685938      5       31
==       24      9   -34.8754859    12.7403727      6       13
==      146     15   -34.3673609    20.3370509      7       13
==      150    210   -33.6537513    17.1449536      8       17
\end{verbatim}
\nolinenumbers

The large weight of the best solution shows the very good convergence of the
docking simulation.

\subsection{Accurate bead representation}

Adjustment of van der Waals radii is recommended for a more accurate 
representation of the occupied volume. In this purpose, we provide a Pymol 
script called \verb@update_pymol_cg_vdw_radii.pml@ in the 
\verb@$HOME/ptools-XX/PyAttract/reduce@ directory. Within Pymol, call this 
script with the command
\begin{verbatim}
run update_pymol_cg_vdw_radii.pml
\end{verbatim}
or from the menu {\tt File -> Run -> select the file}.

With some representations (dots, spheres, mesh and surface), you also need 
to tell Pymol to refresh its view with the command {\tt rebuild}.
Coarse grain van der Waals radii have now their real values and 
reduced molecules their real volume, as shown in Fig.~\ref{real_vdw}.

\begin{figure}[Htbp]
\center
{\textbf A}
\includegraphics*[width=0.15\textwidth]{img/1K79_dna.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.20\textwidth]{img/1K79_prot.png}
\caption{All-atom (green mesh) and reduced (red mesh) representations of both 
partners in the 1K79 protein--DNA complex. With the correct values of coarse grain
van der Waals radii, both representations are equivalent.
DNA (A) and protein (B).}
\label{real_vdw}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Misc. tips and tricks}


\subsection{Troubleshooting}

\subsubsection{Bus error}

On Mac OS, the command \verb@import ptools@ can lead to a "bus error" 
error message. This happens with MacPorts or fink versions of Python. 
A solution is to use the Python provided with the system instead 
(\verb@/usr/bin/python@).

\bibliography{biblio}{}
\bibliographystyle{plain}


\end{document}


		
