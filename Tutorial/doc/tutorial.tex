\documentclass[12pt,a4paper]{article}
\usepackage{ae}
\usepackage{aecompl}
%\usepackage[cm]{aeguill}
\textwidth 16.5cm \textheight 26cm \oddsidemargin -0.5cm \topmargin -2cm
\usepackage{graphicx} % figures
\usepackage{lineno}

\begin{document}


\title{\bf PTools tutorial}
\author{
Adrien Saladin \and 
S\'ebastien Fiorucci \and
Pierre Poulain \and
Chantal Pr\'evost \and
Martin Zacharias
}

\maketitle

\thispagestyle{empty}

\begin{figure}[htbp]
\center
\includegraphics*[width=0.80\linewidth]{img/docking.png}
\end{figure}


\vspace*{3cm}

\noindent
This tutorial presents the PTools library features and its docking application ATTRACT.

\newpage

\tableofcontents{}

\newpage

\section{Set up, compilation and installation}

\subsection{Basic requirements}

The basic requirements are:
\begin{itemize}
\item Python 2.4 or 2.5 and its development library (python2.4-dev or python2.5-dev)
\item gcc (4.x)
\item gfortran (4.x)
\item cvs
\item subversion and subversion-tools
\item cmake
\item doxygen (optional)
\end{itemize}

\subsection{Set up: Dell D420 laptop, Debian Lenny, 32-bit}
This example installation has been performed on a Dell D420 laptop (Intel
Core Duo 1.2~GHz, Debian Lenny, linux kernel 2.6.22).

\paragraph{SCons (make substitute):} {\tt apt-get install scons} \\
(1.34.1-11 version installed)


\paragraph{Boost C++ Libraries} {\tt apt-get install libboost-dev} \\
(1.34.1-11 version installed)


\paragraph{Boost Python Library:} {\tt apt-get install libboost-python} \\
(1.34.1-11 version installed)


\paragraph{libboost Python dev:} {\tt apt-get install libboost-python-dev} \\
(1.34.1-11 version installed)

\paragraph{Subversion:} {\tt apt-get install subversion subversion-tools} \\
(1.4.6dfsg1-2 version installed)

\paragraph{gccxml:} {\tt apt-get install gccxml} \\
(0.9.0+cvs20071228-2 version installed)

\paragraph{Pyplusplus and Pygccxml: }
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is 
{\tt http://www.language-binding.net/pyplusplus/pyplusplus.html}. From the
download section \footnote{\tt https://sourceforge.net/project/showfiles.php?group\_id=118209}, 
get the files {\tt pygccxml-0.9.5.zip} and {\tt Py++-0.9.5.zip}.

\begin{verbatim}
unzip pygccxml-0.9.5.zip
cd pygccxml-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip Py++-0.9.5.zip 
cd Py++-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=PATH:$HOME/soft/bin/
export PYTHONPATH=$HOME/soft/lib/python2.4/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}

\subsection{Set up: Dell D420 laptop, Ubuntu 8.04, 32-bit}
This example installation has been performed on a Dell D420 laptop (Intel
Core Duo 1.2~GHz, Ubuntu 8.04, linux kernel 2.6.24).

\paragraph{SCons (make substitute):} {\tt apt-get install scons} \\
(0.97.0d20071203-1ubuntu1 version installed)

\paragraph{Boost C++ Libraries} {\tt apt-get install libboost-dev} \\
(1.34.1-4ubuntu3 version installed)

\paragraph{Boost Python Library:} {\tt apt-get install libboost-python1.34.1} \\
(1.34.1-4ubuntu3 version installed)

\paragraph{libboost Python dev:} {\tt apt-get install libboost-python-dev} \\
(1.34.1-4ubuntu3 version installed)

\paragraph{gccxml:} This Ubuntu linux distribution have an incompatible gccxml 0.7 version that crashes when parsing headers files. The solution is then to install gccxml from the official CVS repository

The homepage of {\tt gccxml} project is {\tt http://www.gccxml.org} and its official 
CVS repository is {\tt http://www.gccxml.org/HTML/Download.html}.

\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML login
\end{verbatim}
(just press enter when prompted for a password)\\
Follow this command by checking out the source code:
\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML co gccxml
mkdir gccxml-build
cd gccxml-build
cmake ../gccxml -DCMAKE_INSTALL_PREFIX:PATH=/installation/path
make
make install
\end{verbatim}
The "-DC\_MAKE\_INSTALL\_PREFIX" option can be left off if you want to use "/usr/local" as the installation prefix.

\paragraph{Pyplusplus and Pygccxml: }
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is 
{\tt http://www.language-binding.net/pyplusplus/pyplusplus.html}. From the
download section \footnote{\tt https://sourceforge.net/project/showfiles.php?group\_id=118209}, 
get the files {\tt pygccxml-1.0.0.zip} and {\tt Py++-1.0.0.zip}.

\begin{verbatim}
unzip pygccxml-1.0.0.zip
cd pygccxml-1.0.0/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip Py++-1.0.0.zip 
cd Py++-1.0.0/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=PATH:$HOME/soft/bin/
export PYTHONPATH=$HOME/soft/lib/python2.5/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}



\subsection{Set up: Dell Precision T7400, Linux Fedora Core 9, 64-bit}
This example installation has been performed on a Dell Precision T7400 (Intel
Xeon quad-core 2.3~GHz, Linux Fedora Core 9, linux kernel 2.6.25).

\paragraph{SCons (make substitute):}
The scons package provided by Fedora is not up-to-date enough to link Fortran and C++ together and then rise an
error. The last version of scons is obtained at the homepage of the project ({\tt  http://www.scons.org/}).
From the download section \footnote{\tt http://sourceforge.net/project/showfiles.php?group\_id=30337}, 
get the stable file {\tt scons-0.98.5-1.noarch.rpm}.

\begin{verbatim}
 rpm -ivh scons-0.98.5-1.noarch.rpm
\end{verbatim}

\paragraph{Boost C++ Libraries:} {\tt yum install boost boost-devel} \\
(1.34.1-13 version installed)

\paragraph{Python dev:} {\tt yum install python-devel} \\
(2.5.1-26 version installed)

\paragraph{gccxml:}The homepage of {\tt gccxml} project is {\tt http://www.gccxml.org}. 
To install gccxml from the official CVS repository \footnote{\tt http://www.gccxml.org/HTML/Download.html}.

\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML login
\end{verbatim}
(just press enter when prompted for a password)\\
Follow this command by checking out the source code:
\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML co gccxml
mkdir gccxml-build
cd gccxml-build
cmake ../gccxml -DCMAKE_INSTALL_PREFIX:PATH=/installation/path
make
make install
\end{verbatim}
The "-DC\_MAKE\_INSTALL\_PREFIX" option can be left off if you want to use "/usr/local" as the installation prefix.

\paragraph{Pyplusplus and Pygccxml: }
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is 
{\tt http://www.language-binding.net/pyplusplus/pyplusplus.html}. From the
download section \footnote{\tt https://sourceforge.net/project/showfiles.php?group\_id=118209}, 
get the files {\tt pygccxml-0.9.5.zip} and {\tt Py++-0.9.5.zip}.

\begin{verbatim}
unzip pygccxml-0.9.5.zip
cd pygccxml-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip Py++-0.9.5.zip 
cd Py++-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=PATH:$HOME/soft/bin/:/usr/lib/gcc/x86_64-redhat-linux/3.4.6/
export PYTHONPATH=$HOME/soft/lib/python2.4/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}


\subsection{Set up: Dell Precision 690, Linux Fedora Core 7, 64-bit}
This example installation has been performed on a Dell Precision 690 (Intel
Xeon bi-quad core 1.9~GHz, Linux Fedora Core 7, linux kernel 2.6.23).

\paragraph{SCons (make substitute):}
The scons package provided by Fedora is not up-to-date enough to link Fortran and C++ together and then rise an
error. The last version of scons is obtained at the homepage of the project ({\tt  http://www.scons.org/}).
From the download section \footnote{\tt http://sourceforge.net/project/showfiles.php?group\_id=30337}, 
get the stable file {\tt scons-0.98.5-1.noarch.rpm}.

\begin{verbatim}
 rpm -ivh scons-0.98.5-1.noarch.rpm
\end{verbatim}

\paragraph{Boost C++ Libraries:} {\tt yum install boost boost-devel} \\
(1.33.1-15.fc7 version installed)

\paragraph{Python dev:} {\tt yum install python-devel} \\
(2.5-15.fc7 version installed)

\paragraph{gccxml:}The homepage of {\tt gccxml} project is {\tt http://www.gccxml.org}. 
To install gccxml from the official CVS repository \footnote{\tt http://www.gccxml.org/HTML/Download.html}.

\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML login
\end{verbatim}
(just press enter when prompted for a password)\\
Follow this command by checking out the source code:
\begin{verbatim}
cvs -d :pserver:anoncvs@www.gccxml.org:/cvsroot/GCC_XML co gccxml
mkdir gccxml-build
cd gccxml-build
cmake ../gccxml -DCMAKE_INSTALL_PREFIX:PATH=/installation/path
make
make install
\end{verbatim}
The "-DC\_MAKE\_INSTALL\_PREFIX" option can be left off if you want to use "/usr/local" as the installation prefix.

\paragraph{Pyplusplus and Pygccxml: }
The homepage of {\tt pyplusplus} and {\tt pygccxml} projects is 
{\tt http://www.language-binding.net/pyplusplus/pyplusplus.html}. From the
download section \footnote{\tt https://sourceforge.net/project/showfiles.php?group\_id=118209}, 
get the files {\tt pygccxml-0.9.5.zip} and {\tt Py++-0.9.5.zip}.

\begin{verbatim}
unzip pygccxml-0.9.5.zip
cd pygccxml-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

\begin{verbatim}
unzip Py++-0.9.5.zip 
cd Py++-0.9.5/
python setup.py build
python setup.py install --prefix=$HOME/soft
\end{verbatim}

In your {\tt \$HOME/.bashrc} file, then add:
\begin{verbatim}
export PATH=PATH:$HOME/soft/bin/:/usr/lib/gcc/x86_64-redhat-linux/3.4.6/
export PYTHONPATH=$HOME/soft/lib/python2.4/site-packages/
\end{verbatim}

In a Python shell (obtained with the {\tt python} command), test the installation
of PyPlusPlus:
\begin{verbatim}
>>> import pyplusplus
\end{verbatim}

\paragraph{g2c library:} {\tt yum install g2clib-devel} \\
(1.0.5-3.fc7 version installed)

\subsection{Archive download}

From the PTools website {\tt  http://www.ibpc.fr/$\sim$chantal/ptools/},
download the current PTools archive {\tt ptools-XX.tgz} where {\tt XX} is
the version number. Copy the archive {\tt ptools-XX.tgz} in your local 
{\tt \$HOME/soft/} directory and uncompress it:

\begin{verbatim}
tar zxvf  ptools-XX.tgz
\end{verbatim}
The directory {\tt ptools-XX} shoud be created.


\subsection{Compilation}

From the PTools main directory ({\tt \$HOME/soft/ptools-XX}), 
first create the Python/C++ interface:
\begin{verbatim}
python interface.py
\end{verbatim}

Then compile the library:
\begin{verbatim}
scons
\end{verbatim}

Note that {\tt scons -j2} compiles with two processors in parallel.

If scons complains about the g2c library, you may do (as root):
\begin{verbatim}
ln -s /usr/lib64/libg2c.so.0 /usr/lib64/libg2c.so
\end{verbatim}

In case of problem with the gfortran library, you should add directly to the search path (line~87)
of the SConstruct file the location of libgfortran files. For instance: 
\newline Initial search path:
\newline ["/usr/lib","/sw/lib","/usr/lib/gcc/x86\_64-redhat-linux/3.4.6/"]
\newline Add specific path for suse distribution:
\newline ["/usr/lib","/sw/lib","/usr/lib/gcc/x86\_64-redhat-linux/3.4.6/","/usr/lib64/gcc/x86\_64-suse-linux/4.1.2/"]

\subsection{Final test and further documentation}

In the {\tt Tests} directory, one can test the compilation worked:
\begin{verbatim}
python unittest1.py
\end{verbatim}

The expected output should similar to:
\begin{verbatim}
...............
----------------------------------------------------------------------
Ran 16 tests in 0.316s

OK
\end{verbatim}


\section{PTools library usages and capabilities}

\subsection{Directly from C++}

Source code may be parsed by Doxygen, an automatic documentation generator.
This documentation may help for the C++ (and indirectly for the Python)
part of the library. 

If Doxygen is installed, simply type {\tt doxygen} in
the directory which contains the {\tt Doxyfile} ({\tt
\$HOME/soft/ptools-XX}). Then look into the {\tt html}
directory and open with your favorite browser the {\tt index.html} file
generated with doxygen. 

The most important objects and functions to manipulate PDB files are explained in
the following section.

\subsection{From Python through the C++ binding}

If PTools has been installed in the {\tt \$HOME/soft/ptools-XX} directory, 
update your {\tt PYTHONPATH}:

\begin{verbatim}
export PYTHONPATH=$PYTHONPATH:$HOME/soft/ptools/branches/1.0rc/
\end{verbatim}
or add this line at the end of your {\tt \$HOME/.bashrc} file.


From the Python interpreter or from a Python script, 
first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}


\subsubsection{Rigidbody objects}

\paragraph{Load PDB file (for instance {\tt 1BTA.pdb}) into a rigidbody
object.}
\begin{verbatim}
pdb = Rigidbody("1BTA.pdb")
\end{verbatim}


\paragraph{Number of atoms.}
\begin{verbatim}
pdb.Size()
\end{verbatim}


\paragraph{Maximum distance (in \AA) from geometric center.}
\begin{verbatim}
pdb.Radius()
\end{verbatim}


\paragraph{Radius of gyration (in \AA).}
\begin{verbatim}
pdb.RadiusGyration()
\end{verbatim}


\paragraph{Structure translation.}
First create a translation vector as a Coord3D object (for instance 5~\AA\ along the X axis, -3~\AA\ along Y and 1~\AA\ along the Z axis):
\begin{verbatim}
trans = Coord3D(5, 0, 1)
\end{verbatim}
Then, apply the translation vector {\tt trans}:
\begin{verbatim}
pdb.Translate(trans)
\end{verbatim}


\paragraph{Center structure to origin.}
\begin{verbatim}
pdb.CenterToOrigin()
\end{verbatim}


\paragraph{Save structure as PDB file.}
\begin{verbatim}
WritePDB(pdb, "1BTA_centered.pdb")
\end{verbatim}


\subsubsection{Selection objects}

\paragraph{Select CA atoms.}
\begin{verbatim}
sel_ca = pdb.CA()
\end{verbatim}


\paragraph{Select backbone atoms.}
\begin{verbatim}
sel_bkbn = pdb.Backbone()
\end{verbatim}


\paragraph{Select by chain.}
\begin{verbatim}
sel_chainA = pdb.SelectChainId("A")
sel_chainB = pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Select a range of residues.}
\begin{verbatim}
sel_res = pdb.SelectResRange(10, 20)
\end{verbatim}


\paragraph{Get the number of atomes (the size) of a selection.}
\begin{verbatim}
sel_res.Size()
\end{verbatim}



\paragraph{Reunion between two selections.}
\begin{verbatim}
sel_chainAB = sel_chainA | sel_chainB
\end{verbatim}
or directly
\begin{verbatim}
sel_chainAB = pdb.SelectChainId("A") | pdb.SelectChainId("B")
\end{verbatim}


\paragraph{Convert selection to rigidbody object.}
\begin{verbatim}
ca_trace = sel_ca.CreateRigid()
\end{verbatim}

\subsubsection{atom object}

\paragraph{copy atom from rigidbody object.}
\begin{verbatim}
at = pdb.CopyAtom(2)
\end{verbatim}

\paragraph{Set new coordinates}
\begin{verbatim}
new_XYZ = Coord3D(2.1,3.9,5.5)
at.SetCoords(new_XYZ)
\end{verbatim}

\paragraph{Translate atom}
\begin{verbatim}
vector = Coord3D(1.0,1.0,1.0)
at.Translate(vector)
\end{verbatim}


\paragraph{Print atom in pdb-like format}
\begin{verbatim}
at.ToPdbString()
\end{verbatim}

\paragraph{Get atom properties}
\begin{verbatim}
at.GetType()
at.GetResidType()
at.GetAtomCharge()
at.GetChainId()
at.GetResidId()
at.GetAtomId()
at.GetExtra()
\end{verbatim}

\paragraph{Set atom properties}
\begin{verbatim}
at.SetType()
at.SetResidType()
at.SetAtomCharge()
at.SetChainId()
at.SetResidId()
at.SetAtomId()
at.SetExtra()
\end{verbatim}

\section{Docking with PTools: ATTRACT}

This part is illustrated by the docking of a protein/protein complex (1CGI) and
a protein/DNA complex (1K79).

\subsection{Protein--protein complex: 1CGI}

The 1CGI complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1CGI} 
has two partners:
\begin{itemize}
\item the bovine chymotrypsinogen A: chain E, 245 residues, 1799 atoms
\item a variant of the human pancreatic secretory trypsin inhibitor: chain I, 56 residues, 440 atoms
\end{itemize}

\subsubsection{Extraction of the docking partners}

Before docking, one has to separate both partners. This is possible with visualisation
software such as Pymol \footnote{\tt http://pymol.sourceforge.net/} or VMD \footnote{\tt http://www.ks.uiuc.edu/Research/vmd/}, 
and also directly with the PTools library.

Within the Python interpreter, first load the PTools library:
\begin{verbatim}
from ptools import *
\end{verbatim}

Read the PDB file 1CGI.pdb:
\begin{verbatim}
pdb=Rigidbody("1CGI.pdb")
\end{verbatim}

The chain selection allows the separation between chain A and B.
\begin{verbatim}
selectE=pdb.SelectChainId("E")
selectI=pdb.SelectChainId("I")
\end{verbatim}

Create both chains as independant rigid bodys and save them in PDB file. The largest protein is define as the receptor (chain E) and the smallest as the ligand (chain I):

\begin{verbatim}
protE=selectE.CreateRigid()
protI=selectI.CreateRigid()
WritePDB(protE,"receptor.pdb")
WritePDB(protI,"ligand.pdb")
\end{verbatim}
Or more quickly:
\begin{verbatim}
WritePDB(selectE.CreateRigid(),"receptor.pdb")
WritePDB(selectI.CreateRigid(),"ligand.pdb")
\end{verbatim}

\subsubsection{Coarse grain reduction}

This step translates all atom molecule into coarse grain (reduced) molecule for further docking. 

For the receptor: 
\begin{verbatim}
./reduce.py --prot receptor.pdb > receptor.red
\end{verbatim}
In the present case, {\tt receptor.red} contains 522 beads.\\

For the ligand:
\begin{verbatim}
./reduce.py --prot ligand.pdb > ligand.red
\end{verbatim}
In the present case, {\tt ligand.red} contains 126 beads. \\

The {\tt reduce.py} script required the following parameters:

\begin{itemize}
\item {\tt --prot} or {\tt --dna} option, specifies the type of molecule to reduce (respectively protein or DNA)
\item an input all-atom PDB file, for instance {\tt receptor.pdb}
\item an output coarse grain file, for instance {\tt receptor.red}
\end{itemize}

This script also needs definition files:

\begin{itemize}
\item bead topology files ({\tt at2cg.prot.dat} for protein reduction and {\tt at2cg.dna.dat} for DNA reduction )
\item forcefield parameter file ({\tt ff\_param.dat})
\item filetype conversion file ({\tt type\_conversion.dat})
\end{itemize}

The reduced files generated are PDB-like structure files that can be read by most visualisation
programs (rasmol, pymol, VMD). Adjustment of van de Waals radii is recommended for an accurate 
representation of the occupied volume.
Always visualize both all-atom and coarse grain structures to check the reduction worked properly.

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.25\textwidth]{img/1CGI_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation of both proteins in 1CGI. Receptor (A) and ligand (B).}
\end{figure}

\subsubsection{Initial ligand positions}

The systematic docking simulation uses starting points placed around the
receptor.  The Python script {\tt translate.py} employs a slightly modified
Shrake and Rupley \cite{shrake1973} method to define starting positions
from the receptor surface.  The surface generation fonctions are implemented in
the PTools library. The script first reads the coarse grain (reduced)
receptor and ligand files, then generates a grid of points at a certain
distance from the receptor and outputs the grid with a given density.

Note: a density option ({\tt -d}) controls the minimum distance between starting
points (in \AA). The default value is 10.0~\AA. 

In the present case:
\begin{verbatim}
./translate.py receptor.red ligand.red > translation.dat
\end{verbatim}

Visualisation of the starting points may be obtained with any visualisation software by 
renaming {\tt translation.dat} in {\tt translation.pdb}.
Then, remove the first line of {\tt translation.pdb} (indicating the total number of starting points).

\begin{figure}[htbp]
\center
\includegraphics*[width=0.4\textwidth]{img/1CGI_translation.png}
\caption{(All-atom) receptor in green sticks and starting points as orange spheres.}
\end{figure}

For each position in translation (each {\tt ATOM} line of the file {\tt translation.dat}), 
there are 258 associated rotations defined in the file {\tt rotation.dat}. 

\subsubsection{ATTRACT parameters}

ATTRACT parameters are found in the file {\tt attract.inp}. A typical configuration file is:
\begin{verbatim}
    6    0    0
 -34.32940  38.75490  -3.66956   0.00050
  100  2  1  1  1  0  0  0  1  9900.00
  100  2  1  1  1  0  0  0  1  1500.00
  100  2  1  1  1  0  0  0  1  1000.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
   50  2  1  1  1  0  0  0  0   500.00
\end{verbatim}

The first line indicates the number of minimisations performed by ATTRACT
for each starting position (six in the present case). The last six lines are the characteristics of
each minimisation. The first column is the number of steps before the
minimisation stops.  The last column is the square of the cutoff distance
for the calculation of the interaction energy between both partners. 
In the present case, the simulation starts with a very large cutoff value of 9900~\AA$^2$ 
($\sim$ 99~\AA), which is gradually dicreased
to end with 500~\AA$^2$ ($\sim$ 22~\AA).

\paragraph{Note:} Columns with zeros or ones should not be modified, as
well as the second line.

\subsubsection{Initial docking simulation}

A docking simulation with ATTRACT requires:
\begin{itemize}
\item a coarse grain receptor (fixed partner) file ({\tt receptor.red})
\item a coarse grain (mobile partner) file ({\tt ligand.red})
\item the ATTRACT program ({\tt  Attract.py})
\item the coarse grain parameters ({\tt aminon.par})
\item translational starting points ({\tt translation.dat})
\item rotations performed for each translational starting point ({\tt rotation.dat})
\item docking parameters ({\tt attract.inp})
\end{itemize}

ATTRACT can be used with different options:
\begin{itemize}
\item {\tt -s}, performs one single serie of minimisations with the ligand in its initial position.
\item \verb@--ref@, provides a ligand pdb file as a reference. After each docking, the RMSD is calculated between this reference structure and the simulated ligand.
\end{itemize}

A single ATTRACT simulation may thus be obtained by:
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red -s > single.att
\end{verbatim}

The first pdb file provided must be the receptor file (and the second the ligand).
The content of the output file {\tt single.att} is the following:

\newpage
\linenumbers*
\begin{verbatim}

**********************************************************************
**                ATTRACT  (Python edition)                         **
**                version: 0.3                                      **
**********************************************************************
Attract.py: $Id: Attract.py 616 2008-11-25 12:42:39Z asaladin $
using PTools: 614

2008-12-11 00:08:18.212859 ( Thursday December 11 2008, 00:08 )
6 series of minimizations
rstk =  0.0005
Receptor (fixed) receptor.red  has 522 particules
Ligand (mobile) ligand.red  has 126 particules
using reference file: ligand.red
Single mode
@@@@@@@ Translation nb 1 @@@@@@@
----- Rotation nb 1 -----
{{ minimization nb 1 of 6 ; cutoff= 99.50 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  72 iterations
{{ minimization nb 2 of 6 ; cutoff= 38.73 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  2 iterations
{{ minimization nb 3 of 6 ; cutoff= 31.62 (A) ; maxiter= 100
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  3 iterations
{{ minimization nb 4 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  10 iterations
{{ minimization nb 5 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  1 iterations
{{ minimization nb 6 of 6 ; cutoff= 22.36 (A) ; maxiter= 50
number of free variables for the minimizer: 6
CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH             |  1 iterations
      Trans    Rot          Ener    RmsdCA_ref
==        1      1   -58.3541422 1.19455904733
### MAT BEGIN
MAT        0.9973001      0.0414787     -0.0605965      0.4545131 
MAT       -0.0430245      0.9987753     -0.0244310      1.9814388 
MAT        0.0595089      0.0269722      0.9978633     -2.8603610 
MAT        0.0000000      0.0000000      0.0000000      1.0000000 
### MAT END

Finished at:  Thursday December 11 2008, 00:08

\end{verbatim}
\nolinenumbers

\begin{itemize}
\item{\bf line 9:} starting date and time of the simulation
\item{\bf lines 18--20:} minimization 1. Details of minimization number, cutoff in \AA\ and maximum number of iterations (line~14). 
Number of variables (line~15). End of minimization (line~16), either convergence is achieved (iteration number is specified), either maximum number of steps is reached.
\item{\bf lines 21--23:} minimization 2.
\item{\bf lines 24--26:} minimization 3.
\item{\bf lines 27--29:} minimization 4.
\item{\bf lines 30--32:} minimization 5.
\item{\bf lines 33--35:} minimization 6.
\item{\bf lines 36--37:} final result after the 6 minimizations. With a single series of minimization, the default translation ({\tt Trans}) is 1 and the default rotation ({\tt Rot}) is 1. 
Energy ({\tt Ener} is given in RT unit, as well as the C$_{\alpha}$-RMSD 
({\tt RmsdCA\_ref} in \AA) if the \verb@--ref@ option is specified.
\item{\bf lines 38--43:} rotation/translation matrix of the ligand compared to its initial position.
\item{\bf line 45:} end date and time of the simulation.
\end{itemize}

Here, the final energy is -58.35~RT unit and the RMSD is 1.19~\AA, which is pretty close from the initial position. (In a "perfect" simulation, RMSD would
be 0.0).

For a full systematic docking in the translational and rotational space (using both {\tt translation.dat} and {\tt rotation.dat} files):
\begin{verbatim}
./Attract.py receptor.red ligand.red --ref=ligand.red > docking.att &
\end{verbatim}

The output file {\tt docking.att} contains all informations on the docking simulation. 
It contains ithe ouput of all series of minimizations (with the specification of translation and rotation number).

For the 1CGI system, the systematic docking took 19 hours on a single processor of a 64~bit Intel Xeon 1.86 GHz 2 Go RAM computer.
The size of the output file {\tt docking.att} is roughly 77~Mo.

\subsubsection{Docking output analysis}

The 10 best geometries found during the docking simulation can be listed with

\begin{verbatim}
cat docking.att | egrep -e "^==" | sort -n -k4 | head
\end{verbatim}

For the previsous docking simulation of 1CGI, this gives:

\begin{verbatim}
==      133     92   -58.3541443 1.19429783478
==       73    229   -58.3541441 1.19413397471
==      133     21   -58.3541437 1.19566121232
==       73    235   -58.3541436 1.19394986862
==      136     21   -58.3541424 1.19584401069
==      130    141   -58.3541411  1.1930478392
==      194    219   -58.3541410  1.1961246513
==       73      7   -58.3541406 1.19314844151
==      136    155   -58.3541400 1.19273140092
==      163     70   -58.3541387 1.19596166869
\end{verbatim}

With each column meaning:
\begin{enumerate}
\item tag characters ({\tt ==}) to quickly find the result of each set of minimizations
\item translation number (starts at 1)
\item rotation number (starts at 1)
\item final energy of the complex in RT unit
\item final RMSD in \AA, if the \verb@--ref@ option is provided.
\end{enumerate}

Any simulated ligand structure can be extracted with the script {\tt Extract.py}:

\begin{verbatim}
./Extract.py docking.att ligand.red 133 92 > ligand_1.red
\end{verbatim}

with the parameters:
\begin{itemize}
\item the ouput file of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item a translation number ({\tt 133})
\item a rotation number ({\tt 92})
\item an output ligand file ({\tt ligand\_1.red})
\end{itemize}

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_front.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.30\textwidth]{img/1CGI_dock1_top.png}
\caption{Reduced representations of receptor (green), ligand at reference position (red)
and ligand from the best solution (lowest energy) of the docking (blue). Front (A) and top (B) views.
With a RMSD of 1.2~\AA\ between the reference and the simulated ligand structures, the docking 
simulation found very well the initial complex structure.}
\end{figure}


In case you know the experimental structure of your system (as in this example), it is possible to calculate the
interface RMSD (iRMSD) and the native fraction (fnat) as defined by the CAPRI contest \footnote{\tt http://capri.ebi.ac.uk}
using the following scripts:

\begin{verbatim}
irmsd.py receptor.red ligand.red ligand_1.red
fnat.py receptor.red ligand.red ligand_1.red
\end{verbatim}

For iRMSD, output is in \AA\ and fnat is given as a proportion (between 0.0 and 1.0). Parameters are defined as:
\begin{itemize}
\item the receptor file ({\tt receptor.red})
\item the initial ligand file ({\tt ligand.red})
\item the output ligand file ({\tt ligand\_1.red})
\end{itemize}

Our clustering algorithm implemented in cluster.py can rapidly filter near identical solutions 
without requiring a preselected number of desired clusters.
The algorithm is based on RMSD comparison and an additional energy criterion can be included 
(see script options, by default RMSD and energy criterions are 1~\AA and 1~RT unit respectively).

\begin{verbatim}
cluster.py docking.att ligand.red > docking.clust
\end{verbatim}

with the parameters:
\begin{itemize}
\item an ouput of the docking simulation ({\tt docking.att})
\item the initial ligand file ({\tt ligand.red})
\item an output cluster file ({\tt docking.clust})
\end{itemize}

The first lines of the output cluster file are:

\linenumbers*
\begin{verbatim}
      Trans    Rot          Ener    RmsdCA_ref   Rank   Weight
==      133     92   -58.3541443     1.1942978      1       55
==      196    132   -40.3704483    48.8195971      2        1
==      164    212   -39.3828793     6.4968451      3        2
==       71    102   -38.7843145    14.7084754      4       14
==       73    126   -38.5826662    11.5175880      5        3
==      129    223   -38.3872389    12.3477797      6        3
==      132    245   -38.3429828    14.0028863      7       10
==      133    131   -38.1570360    16.0382603      8       17
\end{verbatim}
\nolinenumbers

Line 1 is a comment line, next lines are clusters. For each cluster (line)
is specified:
\begin{itemize}
\item a representative structure with the translation and rotation
numbers (column 2, {\tt Trans}, and 3, {\tt Rot}), interaction energy (column 4, {\tt Ener}) and RMSD (column 5, {\tt RmsdCA\_ref}) from the reference ligand structure
\item the number of the cluster (column 6, {\tt Rank})
\item the number of structures (docking solutions) in this cluster (column
7, {\tt Weight})
\end{itemize}

\subsection{Protein--DNA complex: 1K79}

The 1K79 complex \footnote{\tt http://www.rcsb.org/pdb/cgi/explore.cgi?pdbId=1K79} 
has two partners,
\begin{itemize}
\item the ETS protein: chain A, 104 residues, 873 atoms (defined in the following as the receptor)
\item a DNA molecule: chain B and C, 30 bases, 607 atoms (defined in the following as the ligand)
\end{itemize}

\subsubsection{Extraction of the docking partners}

Both partners are extracted automatically with the PTools library from the Python interpreter:
\begin{verbatim}
from ptools import *
pdb=Rigidbody("1K79.pdb")
selA=pdb.SelectChainId("A")
selB=pdb.SelectChainId("B")
selC=pdb.SelectChainId("C")
WritePDB(selA.CreateRigid(), "receptor.pdb")
WritePDB( (selB | selC).CreateRigid(), "ligand.pdb")
exit()
\end{verbatim}

\subsubsection{Coarse grain reduction}

This step translates all atom molecule into coarse grain (reduced) molecule for further docking. 

For the receptor (protein): 
\begin{verbatim}
./reduce.py --prot receptor.pdb > receptor.red
\end{verbatim}
This command generates few warnings due to missing atoms in the Lys436 residue. 
\begin{verbatim}
./reduce.py --prot receptor.pdb > receptor.red
./at2cg.prot.dat: found the definition of residues ARG GLU GLN LYS TRP MET PHE TYR HIS GLY ASN ALA ASP CYS ILE LEU PRO SER THR VAL 
./at2cg.prot.dat: created the partition for residues ARG(3 beads) GLU(3 beads) GLN(3 beads) LYS(3 beads) TRP(3 beads) MET(3 beads) PHE(3 beads) TYR(3 beads) HIS(3 beads) GLY(1 beads) ASN(2 beads) ALA(2 beads) ASP(2 beads) CYS(2 beads) ILE(2 beads) LEU(2 beads) PRO(2 beads) SER(2 beads) THR(2 beads) VAL(2 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file receptor.pdb with 873 atoms 
Number of residues: 104
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom CG in bead CB 16 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom CE in bead CE 17 for residue LYS 436. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 246 beads 
\end{verbatim}
Finaly, the reduced protein, {\tt receptor.red}, contains 246 beads.\\

For the ligand (DNA), do not forget the \verb@--dna@ option:
\begin{verbatim}
./reduce.py --dna ligand.pdb > ligand.red
\end{verbatim}
This also generates few warnings due to incomplete base:
\begin{verbatim}
./at2cg.dna.dat: found the definition of residues A G C T 
./at2cg.dna.dat: created the partition for residues A(6 beads) G(6 beads) C(5 beads) T(5 beads) 
./ff_param.dat: reading force field parameters for bead 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 
Load atomic file ligand.pdb with 607 atoms 
Number of residues: 30
Reading all atoms and filling beads:
Coarse graining:
ERROR: missing atom O1P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue T 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O1P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom O2P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
ERROR: missing atom P in bead GP1 30 for residue C 1. Please fix your PDB!
Continue execution as required ...
Coarse grain (reduced) output: 162 beads
\end{verbatim}

The reduced DNA, {\tt ligand.red}, ends up with 162 beads. \\

As previously said, the reduced files generated are PDB-like structure files that can be read by most visualisation
programs (rasmol, pymol, VMD). Adjustment of van de Waals radii is recommended for an accurate 
representation of the occupied volume.
Always visualize both all-atom and coarse grain structures to check the reduction worked properly.

\begin{figure}[htbp]
\center
{\textbf A}
\includegraphics*[width=0.35\textwidth]{img/1K79_receptor.png}
\hspace*{2cm}
{\textbf B}
\includegraphics*[width=0.20\textwidth]{img/1K79_ligand.png}
\caption{All-atom (green sticks) and reduced (red spheres) representation of both partners in 1K79. Receptor, protein (A) and ligand, DNA (B).}
\end{figure}

{\Huge To continue....}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Misc. tips and tricks}


\subsection{Troubleshooting}

\subsubsection{Bus error}
On Mac OS, the command "import ptools" can lead to a "bus error" error message. This happens with MacPorts or 
fink versions of python. Solution: use the python provided with the system instead (/usr/bin/python)



\begin{thebibliography}{99}

\bibitem{shrake1973} A. Shrake, and J.A. Rupley, 
{\it Environment and exposure to solvent of protein atoms. Lysozyme and
isulin}, 
Journal of Molecular Biology, {\bf 79}:351-364, 1973.

\end{thebibliography}
\end{document}


		
